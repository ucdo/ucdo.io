+++
date = '2025-06-24T15:11:14+08:00'
draft = false
title = '分布式锁'
+++

#  为什么需要分布式锁
## 并发太高导致的数据竞争和可能不一致的问题：比如MySQL中库存的扣减
### 单机模式
直接使用 sync.Mutex锁来对操作进行加锁
### 多个服务
#### 悲观锁
1. select ... for update
2. 直接变成串行，但是能解决可能导致的数据不一致的问题
3. 并发量下降
#### 乐观锁
1. 使用版本控制机制，version来操作数据
2. 更新时 set version + 1 where version = // 之前查询出来的version
3. 但是因为乐观锁会出现冲突，所以需要重试
4. 这里的重试次数还是挺关键的。如果并发和竞争巨大，可以根据业务是否改成悲观锁

#### 分布式锁
1. 核心：redis的setnx。将获取和设置变成原子操作
2. 问题
   1. 如果还没释放锁，服务就挂了怎么办？
      1.设置过期时间
    2. 如果还没执行完成过期时间就到了怎么办
       1. 续费
    3. 如果迟迟没有执行完，但是一直续费，阻塞其他业务怎么办
    4. 安全性：别人不能删你设置的setnx  （lua脚本）
       1. 设置值之后保存，删除时对比 
3. redlock 为什么会有redlock
   1. 解决redis集群上设置锁的问题。常规是一个master多个slave，然后进行数据同步。但是如果是设置了master但是因为网络故障或者断电宕机，但是slave没有设置成功或者部分成功的问题
   2. redlock就是把集群里所有的redis都当成master并且都进行setnx操作。setnx的redis数量 >= redis总数 / 2 + 1 就表示成功了
   3. 同时还需要注意：因为设置这些setnx也是需要耗时的，所以在设置过期时需要减去耗时以及服务器的时间漂移 * 因子